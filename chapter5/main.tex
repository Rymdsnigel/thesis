\chapter{Conclusions}
The goal of this thesis was to implement some kind of algorithm for synchronizing rendering on different computers over an network. This has been achieved using different algorithms for synchronization and adapting the rendering.

Some important steps in development:
\begin{enumerate}
  \item Making the animations on the clients depend on the time. 
  \item Making sure that the client and the server agreed on a timestamp.
  \item Using the agreed time in the animation.
  \item Calculate the network-latency of a specific client.
  \item Use this latency to delay animating. 
  \item Find a convenient way to emulate network latencys.
\end{enumerate}

\section {Testing the application}
The application has during development been tested over localhost, running the server and all clients on the same computer, applying delays using netem as descibed in section ???. It has also been run on a local network with the server running on one computer and the clients on other computers. 

The synchronization has been evaluated by logging the time when each client plays a step in the animation. Logs are written to file for evaluation. An example of a log can be found in appendix A, here we can see that before applying the latencies we get a delay of around 30 ms. The client ports in this testrun has a delay of 20 ms respectively 50 ms, so a 30 ms async seems reasonable. After applying the latencies we get a delay between the animations of between 0 and 3 ms. 

Since the application is a distributed system testing through logging of timestamps requires the computer clocks of the computers running the clients needs to be synchronized to make any use of the log. This is why the synchronization part only has been investigated with all the parts of the application running on one computer. 

\chapter{Limitations}

\subsection*{Outlook -- suggested improvements}
The demo is a proof of concept and there are a few recommended improvements to it. 

The first suggested step would be to evaluate the system using UDP or by replacing the network-layer with some solution like zeromq or redis. Both of these provides solutions for a publish/subscribe server. 

The input for the server should be generalized so that it the input device could be replaced by for example a mixer-table. 
